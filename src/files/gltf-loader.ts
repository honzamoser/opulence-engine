/* Generated by Claude Sonnet 4.5 */

import { load } from "@loaders.gl/core";
import { GLTFLoader, postProcessGLTF } from "@loaders.gl/gltf";
import { Mesh } from "../renderer/mesh";
import { vec3, quat, mat4 } from "wgpu-matrix";

export interface GLTFMeshInstance {
  mesh: Mesh;
  position: [number, number, number];
  rotation: [number, number, number]; // Euler angles in radians [x, y, z]
  scale: [number, number, number];
  name?: string;
  nodeIndex?: number;
}

export interface GLTFLoadResult {
  instances: GLTFMeshInstance[];
  meshes: Mesh[];
}

/**
 * Loads a GLB/GLTF file and converts it into renderable Mesh instances with transform data
 * @param path Path to the GLTF/GLB file
 * @param options Options for loading
 * @returns Promise containing mesh instances with their original transforms
 */
export async function loadglb(
  path: string,
  options: { preserveTransforms?: boolean } = {},
): Promise<GLTFMeshInstance[]> {
  const { preserveTransforms = true } = options;

  const gltf = await load(path, GLTFLoader);
  const scene = postProcessGLTF(gltf);

  if (preserveTransforms && scene.scenes && scene.scenes.length > 0) {
    // Load with scene graph transforms
    return loadWithTransforms(scene);
  } else {
    // Legacy mode: just return meshes at origin
    return loadMeshesOnly(scene);
  }
}

/**
 * Load meshes with their original transforms from the GLTF scene graph
 */
function loadWithTransforms(gltfData: any): GLTFMeshInstance[] {
  const instances: GLTFMeshInstance[] = [];
  const meshCache = new Map<string, Mesh>();

  console.log("=== GLTF Load Debug ===");
  console.log("Total nodes:", gltfData.nodes?.length);
  console.log("Total meshes:", gltfData.meshes?.length);
  console.log("Total scenes:", gltfData.scenes?.length);

  // Get the default scene
  const sceneIndex = gltfData.scene?.index ?? 0;
  const scene = gltfData.scenes?.[sceneIndex];

  console.log("Scene index:", sceneIndex);

  if (!scene) {
    console.warn("No scene found, using loadMeshesOnly");
    return loadMeshesOnly(gltfData);
  }

  // Traverse scene graph starting from root nodes
  const rootNodes = scene.nodes || [];
  console.log("Root nodes count:", rootNodes.length);
  console.log("First root node type:", typeof rootNodes[0]);

  for (let i = 0; i < rootNodes.length; i++) {
    const rootNodeRef = rootNodes[i];

    // In post-processed GLTF, nodes are objects not indices
    const node =
      typeof rootNodeRef === "object"
        ? rootNodeRef
        : gltfData.nodes?.[rootNodeRef];

    if (node) {
      traverseNode(node, i, mat4.identity(), instances, meshCache);
    }
  }

  console.log(`Total instances created: ${instances.length}`);
  console.log("=== End GLTF Load Debug ===");

  return instances;
}

/**
 * Recursively traverse the GLTF scene graph
 */
function traverseNode(
  node: any,
  nodeIndex: number,
  parentTransform: Float32Array,
  instances: GLTFMeshInstance[],
  meshCache: Map<string, Mesh>,
): void {
  // Calculate this node's local transform
  const localTransform = getNodeTransform(node);

  // Combine with parent transform
  const worldTransform = mat4.multiply(parentTransform, localTransform);

  console.log(`Node ${nodeIndex} (${node.name || "unnamed"}):`);
  console.log(`  Has mesh: ${node.mesh !== undefined}`);

  // If this node has a mesh, create instances
  if (node.mesh !== undefined && node.mesh !== null) {
    // In post-processed GLTF, node.mesh is the mesh object itself
    const gltfMesh = node.mesh;

    console.log(`  Mesh name: ${gltfMesh.name || "(unnamed)"}`);
    console.log(`  Primitives count: ${gltfMesh.primitives?.length || 0}`);

    if (gltfMesh.primitives && gltfMesh.primitives.length > 0) {
      // GLTF meshes can have multiple primitives
      for (
        let primIndex = 0;
        primIndex < gltfMesh.primitives.length;
        primIndex++
      ) {
        const primitive = gltfMesh.primitives[primIndex];

        // Create unique cache key using mesh name and primitive index
        const meshKey = `${gltfMesh.name || nodeIndex}_${primIndex}`;
        let mesh = meshCache.get(meshKey);

        if (!mesh) {
          console.log(`  Creating mesh for primitive ${primIndex}`);
          mesh = convertPrimitiveToMesh(primitive);
          if (mesh) {
            meshCache.set(meshKey, mesh);
          }
        } else {
          console.log(`  Using cached mesh for primitive ${primIndex}`);
        }

        if (mesh) {
          // Decompose world transform into position, rotation, scale
          const { position, rotation, scale } = decomposeMat4(worldTransform);

          // Convert quaternion to Euler angles for TransformComponent compatibility
          const eulerRotation = quaternionToEuler(rotation);

          console.log(
            `  Instance created - pos: [${position[0].toFixed(2)}, ${position[1].toFixed(2)}, ${position[2].toFixed(2)}]`,
          );

          instances.push({
            mesh,
            position,
            rotation: eulerRotation,
            scale,
            name: node.name || `node_${nodeIndex}_prim_${primIndex}`,
            nodeIndex,
          });
        } else {
          console.warn(`  Failed to create mesh for primitive ${primIndex}`);
        }
      }
    } else {
      console.warn(`  Mesh has no primitives`);
    }
  }

  // Traverse children
  if (node.children && node.children.length > 0) {
    console.log(`  Children: ${node.children.length}`);
    for (let c = 0; c < node.children.length; c++) {
      const childNode = node.children[c];

      if (childNode) {
        traverseNode(childNode, c, worldTransform, instances, meshCache);
      }
    }
  }
}

/**
 * Get the local transform matrix for a node
 */
function getNodeTransform(node: any): Float32Array {
  if (node.matrix) {
    // Node has a matrix directly
    return new Float32Array(node.matrix);
  }

  // Build matrix from TRS (Translation, Rotation, Scale)
  const translation = node.translation || [0, 0, 0];
  const rotation = node.rotation || [0, 0, 0, 1]; // quaternion
  const scale = node.scale || [1, 1, 1];

  // Create transform matrix from TRS
  const translationMat = mat4.translation(translation);
  const rotationMat = mat4.fromQuat(rotation);
  const scaleMat = mat4.scaling(scale);

  // Combine: T * R * S
  let transform = mat4.multiply(translationMat, rotationMat);
  transform = mat4.multiply(transform, scaleMat);

  return transform;
}

/**
 * Decompose a 4x4 matrix into position, rotation (quaternion), and scale
 */
function decomposeMat4(matrix: Float32Array): {
  position: [number, number, number];
  rotation: [number, number, number, number];
  scale: [number, number, number];
} {
  // Extract translation (last column)
  const position: [number, number, number] = [
    matrix[12],
    matrix[13],
    matrix[14],
  ];

  // Extract scale (length of each basis vector)
  let sx = Math.sqrt(
    matrix[0] * matrix[0] + matrix[1] * matrix[1] + matrix[2] * matrix[2],
  );
  let sy = Math.sqrt(
    matrix[4] * matrix[4] + matrix[5] * matrix[5] + matrix[6] * matrix[6],
  );
  let sz = Math.sqrt(
    matrix[8] * matrix[8] + matrix[9] * matrix[9] + matrix[10] * matrix[10],
  );

  // Prevent division by zero
  const epsilon = 0.000001;
  if (sx < epsilon) sx = 1;
  if (sy < epsilon) sy = 1;
  if (sz < epsilon) sz = 1;

  const scale: [number, number, number] = [sx, sy, sz];

  // Extract rotation by removing scale from matrix
  const rotationMatrix = mat4.create();
  rotationMatrix[0] = matrix[0] / sx;
  rotationMatrix[1] = matrix[1] / sx;
  rotationMatrix[2] = matrix[2] / sx;
  rotationMatrix[3] = 0;

  rotationMatrix[4] = matrix[4] / sy;
  rotationMatrix[5] = matrix[5] / sy;
  rotationMatrix[6] = matrix[6] / sy;
  rotationMatrix[7] = 0;

  rotationMatrix[8] = matrix[8] / sz;
  rotationMatrix[9] = matrix[9] / sz;
  rotationMatrix[10] = matrix[10] / sz;
  rotationMatrix[11] = 0;

  rotationMatrix[12] = 0;
  rotationMatrix[13] = 0;
  rotationMatrix[14] = 0;
  rotationMatrix[15] = 1;

  // Convert rotation matrix to quaternion
  const q = quat.fromMat(rotationMatrix);
  const rotation: [number, number, number, number] = [q[0], q[1], q[2], q[3]];

  // Validate quaternion - if NaN, use identity
  if (
    isNaN(rotation[0]) ||
    isNaN(rotation[1]) ||
    isNaN(rotation[2]) ||
    isNaN(rotation[3])
  ) {
    console.warn(
      "Invalid quaternion from matrix decomposition, using identity",
    );
    rotation[0] = 0;
    rotation[1] = 0;
    rotation[2] = 0;
    rotation[3] = 1;
  }

  return { position, rotation, scale };
}

/**
 * Legacy mode: Load meshes without transform data (all at origin)
 */
function loadMeshesOnly(gltfData: any): GLTFMeshInstance[] {
  const instances: GLTFMeshInstance[] = [];

  // Iterate through all meshes in the GLTF scene
  for (const gltfMesh of gltfData.meshes || []) {
    // Each mesh can have multiple primitives
    for (const primitive of gltfMesh.primitives || []) {
      const mesh = convertPrimitiveToMesh(primitive);
      if (mesh) {
        instances.push({
          mesh,
          position: [0, 0, 0],
          rotation: [0, 0, 0],
          scale: [1, 1, 1],
          name: gltfMesh.name || "mesh",
        });
      }
    }
  }

  return instances;
}

/**
 * Converts a GLTF primitive into a Mesh instance
 * Vertex format: Position (3) + Normal (3) + Color/Tangent (4) = 10 floats per vertex
 */
function convertPrimitiveToMesh(primitive: any): Mesh | null {
  const attributes = primitive.attributes;

  if (!attributes.POSITION) {
    console.warn("Primitive missing POSITION attribute");
    return null;
  }

  const positions = attributes.POSITION.value;
  const normals = attributes.NORMAL?.value;
  const texcoords = attributes.TEXCOORD_0?.value;
  const tangents = attributes.TANGENT?.value;
  const colors = attributes.COLOR_0?.value;

  const vertexCount = positions.length / 3;

  // Vertex format: Position(3) + Normal(3) + Color/Tangent(4) = 10 floats
  const vertices = new Float32Array(vertexCount * 10);

  // Track bounds for debugging
  let minX = Number.POSITIVE_INFINITY,
    maxX = Number.NEGATIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY,
    maxY = Number.NEGATIVE_INFINITY;
  let minZ = Number.POSITIVE_INFINITY,
    maxZ = Number.NEGATIVE_INFINITY;

  for (let i = 0; i < vertexCount; i++) {
    const offset = i * 10;
    const posOffset = i * 3;

    // Position (3 floats)
    const x = positions[posOffset + 0];
    const y = positions[posOffset + 1];
    const z = positions[posOffset + 2];

    vertices[offset + 0] = x;
    vertices[offset + 1] = y;
    vertices[offset + 2] = z;

    // Track bounds
    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);
    minZ = Math.min(minZ, z);
    maxZ = Math.max(maxZ, z);

    // Normal (3 floats)
    if (normals) {
      vertices[offset + 3] = normals[posOffset + 0];
      vertices[offset + 4] = normals[posOffset + 1];
      vertices[offset + 5] = normals[posOffset + 2];
    } else {
      // Default normal pointing up
      vertices[offset + 3] = 0.0;
      vertices[offset + 4] = 1.0;
      vertices[offset + 5] = 0.0;
    }

    // Color/Tangent (4 floats)
    // Priority: tangents > colors > texcoords > default white
    if (tangents) {
      const tangentOffset = i * 4;
      vertices[offset + 6] = tangents[tangentOffset + 0];
      vertices[offset + 7] = tangents[tangentOffset + 1];
      vertices[offset + 8] = tangents[tangentOffset + 2];
      vertices[offset + 9] = tangents[tangentOffset + 3];
    } else if (colors) {
      const colorOffset = i * 4; // Assuming RGBA
      vertices[offset + 6] = colors[colorOffset + 0];
      vertices[offset + 7] = colors[colorOffset + 1];
      vertices[offset + 8] = colors[colorOffset + 2];
      vertices[offset + 9] = colors[colorOffset + 3] ?? 1.0;
    } else if (texcoords) {
      const uvOffset = i * 2;
      vertices[offset + 6] = texcoords[uvOffset + 0];
      vertices[offset + 7] = texcoords[uvOffset + 1];
      vertices[offset + 8] = 0.0;
      vertices[offset + 9] = 1.0;
    } else {
      // Default white color
      vertices[offset + 6] = 1.0;
      vertices[offset + 7] = 1.0;
      vertices[offset + 8] = 1.0;
      vertices[offset + 9] = 1.0;
    }
  }

  // Extract indices
  let indices: Uint16Array;
  if (primitive.indices) {
    const indexData = primitive.indices.value;
    // Convert to Uint16Array if necessary
    if (indexData instanceof Uint16Array) {
      indices = indexData;
    } else if (indexData instanceof Uint32Array) {
      // Convert Uint32Array to Uint16Array (may cause issues with large meshes)
      console.warn("Converting Uint32Array indices to Uint16Array");
      indices = new Uint16Array(indexData);
    } else {
      indices = new Uint16Array(indexData);
    }
  } else {
    // Generate indices for non-indexed geometry
    indices = new Uint16Array(vertexCount);
    for (let i = 0; i < vertexCount; i++) {
      indices[i] = i;
    }
  }

  // Ensure index count is even for 4-byte alignment (Uint16Array = 2 bytes each)
  // GPU buffers must be aligned to 4 bytes
  if (indices.length % 2 !== 0) {
    const paddedIndices = new Uint16Array(indices.length + 1);
    paddedIndices.set(indices);
    paddedIndices[indices.length] = 0; // Pad with 0 (won't be rendered)
    indices = paddedIndices;
  }

  // Log mesh bounds for debugging
  console.log(
    `Mesh created: ${vertexCount} vertices, ${indices.length} indices`,
  );
  console.log(`  Bounds X: [${minX.toFixed(3)}, ${maxX.toFixed(3)}]`);
  console.log(`  Bounds Y: [${minY.toFixed(3)}, ${maxY.toFixed(3)}]`);
  console.log(`  Bounds Z: [${minZ.toFixed(3)}, ${maxZ.toFixed(3)}]`);

  return new Mesh(vertices, indices);
}

/**
 * Helper: Convert quaternion to Euler angles (radians)
 */
export function quaternionToEuler(
  q: [number, number, number, number],
): [number, number, number] {
  const [x, y, z, w] = q;

  // Roll (x-axis rotation)
  const sinr_cosp = 2 * (w * x + y * z);
  const cosr_cosp = 1 - 2 * (x * x + y * y);
  const roll = Math.atan2(sinr_cosp, cosr_cosp);

  // Pitch (y-axis rotation)
  const sinp = 2 * (w * y - z * x);
  const pitch =
    Math.abs(sinp) >= 1 ? (Math.sign(sinp) * Math.PI) / 2 : Math.asin(sinp);

  // Yaw (z-axis rotation)
  const siny_cosp = 2 * (w * z + x * y);
  const cosy_cosp = 1 - 2 * (y * y + z * z);
  const yaw = Math.atan2(siny_cosp, cosy_cosp);

  return [roll, pitch, yaw];
}

/**
 * Simplified loading: Returns only meshes (backward compatible)
 */
export async function loadglbMeshes(path: string): Promise<Mesh[]> {
  const instances = await loadglb(path, { preserveTransforms: false });
  return instances.map((inst) => inst.mesh);
}
